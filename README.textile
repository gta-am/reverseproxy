h1. ReverseProxy module for Play!

h2. What is ReverseProxy?

ReverseProxy enables communication between *Play built-in server* and a *Reverse-Proxy server* either via HTTP and HTTPS schemes,
e.g., Nginx, Apache, Lighttpd.

h2. Requirements

* A Reverse-Proxy server configured
* For SSL, a *certificate* and its *key*

h2. Configuration

Set the following properties in conf/application.conf

bc. reverse_proxy.enable=true
reverse_proxy.http.address=127.0.0.1
reverse_proxy.http.port=80
reverse_proxy.https.port=443

* reverse_proxy.enable - For enabling or disabling the switching between the Play-App and the Reverse-Proxy.
* reverse_proxy.http.address - The Reverse-Proxy address.
* reverse_proxy.http.port - The Reverse-Proxy HTTP listening port.
* reverse_proxy.https.port - The Reverse-Proxy HTTPS listening port.

h2. HTTPS support

In order to communicate between Reverse-Proxy server and Play built-in server either by HTTP or HTTPS protocol,
Play needs *Java keystore* or simple *cert and key* files and _since you have to create a Certificate and its Key for the Reverse-Proxy server,
you can use the same ones_.

To start an HTTPS connector for your application, just declare the https.port configuration property in your application.conf file:

bc. http.port=9000
https.port=9443

You need to put your certificates in the conf directory. Play supports X509 certificates and keystore certificates. The X509 certificates must be named as follow:
host.cert for the certificate and host.key for the key. If you are using keystore, then, by default it should be named certificate.jks.

If you are using X509 certificates, then the following parameters can be configured through your application.conf:

bc. # X509 certificates
certificate.key.file=conf/host.key
certificate.file=conf/host.cert
# In case your key file is password protected
certificate.password=secret
trustmanager.algorithm=JKS

In case your are using keystore:

bc. keystore.algorithm=JKS
keystore.password=secret
keystore.file=conf/certificate.jks

Note that the values above are the default values. If you use these default values, they are not required to be explicitly in application.conf file,
however, if your certificate doesn't use the default names, you must add your custom values.

*You can generate self signed certificates using openssl:*
# Generate a Private Key
<pre><code>openssl genrsa -des3 -out host.key 1024</code></pre>
# Generate a CSR (Certificate Signing Request)
<pre><code>openssl req -new -key host.key -out host.csr</code></pre>
# Remove Passphrase from Key
<pre><code>cp host.key host.key.org
openssl rsa -in host.key.org -out host.key</code></pre>
# Generating a Self-Signed Certificate
<pre><code>openssl x509 -req -days 365 -in host.csr -signkey host.key -out host.crt</code></pre>
# Installing the Private Key and Certificate
<pre><code>Depends on the Reverse-Proxy server.</code></pre>
# Configuring SSL Enabled Virtual Hosts
<pre><code>Depends on the Reverse-Proxy server.</code></pre>

If you are using the java keystore mechanism, then the following properties can be configured in your application.conf:

bc. # Keystore
ssl.KeyManagerFactory.algorithm=SunX509
trustmanager.algorithm=JKS
keystore.password=secret
keystore.file=certificate.jks

The values above are the default values.

*You can generate self signed certificates using Java Keytool:*

bc. keytool -genkey -keyalg RSA -alias selfsigned -keystore certificate.jks -storepass secret -validity 360 -keysize 1024

h2. Usage

Add this module to your dependecy.yml file

h3. Controllers

There are two annotation for forcing the communication with a Reverse-Proxy server:
* *@SwitchScheme* is strictly for _Methods_ and has two optional values:
** type = SchemeType.HTTP or SchemeType.HTTPS, for using either HTTP or HTTPS protocol.
** keepUrl = true or false (default value), for storing the ReferredUrl into a cookie.

* *@GlobalSwitchScheme* is strictly for _Classes_ and has one optional value:
** type = SchemeType.HTTP (default value) or SchemeType.HTTPS, for using either HTTP or HTTPS protocol.

With _GlobalSwitchScheme_ all Methods from a Controller will use the specified or default SchemeType value, unless
some of its methods are annotated with SwitchScheme, in which case, those method will override the global SchemeType value.

*You shall annotate a method that requires authentication/authorization as:*

bc. @SwitchScheme(type = SchemeType.HTTP, keepUrl = true)
public satic void restrictedMethod(){
    ...
}

In this way, a cookie is created for storing the REFERRED_URL and your app shall redirect to a authentication view (e.g., login);
when the app validates a user is authentic, the app shall redirect to the restrictedMethod route (REFERRED_URL).

h3. @Interceptor
If you going to use _interceptors_ it is suggested to decouple the _controller part_ from the _interceptor part_
and annotate the Interceptor Class with @Interceptor, so that when the plugin enhances the controllers, skips the _interceptors_

h3. Invoking Actions

An Action shall not be invoking by Controller.action()
An Action is considered to be public static void.......

h4. Invoking an _Action_ from _another Action_ of the _same Controller_

For invoking an Action from another Action of the same Controller, you must call

bc. render("@action") or render("@Controller.action") or render("@package.Controller.action")

bc. public class ControllerA extends Controller {
    public static actionOne() {
        render("@actionTwo"); // renders views/Controller/action.html
    }
    public static actionTwo(){
        // Do logic...
        render()
    }
}

h4. Invoking an _Action_ from _another Action_ of _different Controller_

For invoking an Action from another Action of the same Controller, you must use its URI pattern from conf/routes file

bc. GET     /actionTwo                            ControllerB.actionTwo

bc. public class ControllerA extends Controller {
    public static void actionOne() {
        UrlUtility.redirectByReverseRouting("ControllerB.actionTwo"); // Invoke GET /action
    }
}
public class ControllerB extends Controller {
    public static void actionTwo(){
        // Do logic...
        // Invoked from ControllerA.actionOne
        render()
    }
}


h2. Sample application

A sample demo is part of the distribution

Process as follows in order to run them.

h2. Credits

Author: Omar O. Román
Coauthor: Omar García G.
